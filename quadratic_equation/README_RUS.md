# Модуль решения квадратных уравнений
Этот модуль решает квадратные уравнения в вещественных числах и обеспечивает лучшую точность, чем обычные решения в краевых ситуациях.


## Использование
Просто добавьте этот модуль в ваш проект C/C++, включите заголовочный файл и добавьте зависимости:
1. Добавьте файлы `quadratic_equation.c` и `quadratic_equation.h` в ваш проект.
2. Включите заголовочный файл (`#include "quadratic_equation.h"``) в ваш исходный код.
3. Добавьте необходимые библиотечные зависимости в команду компиляции/линковки:
    * **`libm (-lm)`** − это жесткая зависимость и ее необходимо включить.
    * **`libquadmath (-lquadmath)`** − это необязательная зависимость, которую можно включить в разделе CONFIG в заголовочном файле. Если она включена, внутренние вычисления выполняются над типом float128, что может улучшить точность результата в редких случаях. Если вы используете quadmath в своём проекте, почему бы не включить его и здесь?

Альтернативно, вы можете скомпилировать этот модуль в статическую библиотеку с помощью команды `make`.


## Контракт
Основная функция этого модуля − `solve_equation()`.  Ее сигнатура:\
`quadratic_roots solve_equation(double a, double b, double c)`\
где a, b и c - коэффициенты для уравнения `ax^2 + bx + c = 0`\
Она возвращает структуру `quadratic_roots` со следующими полями:
```
typedef struct quadratic_equation_result_struct {
  double root[2];         // массив, хранящий корни
  int num_roots;          // количество найденных корней (по умолчанию от 0 до 2)
  solve_equation_return_status err;  // код статуса выполнения
  const char* status_message;        // сообщение о статусе выполнения
} quadratic_roots;
```
* `double root[2]`: массив, хранящий корни уравнения. Если уравнение имеет только один корень, оба значения будут равны. Если уравнение не имеет корней, массив будет содержать значения NaN.
* `int num_roots`: количество найденных корней, которое может быть 0, 1 или 2. **Существует особый случай**, когда все коэффициенты равны 0, и уравнение имеет бесконечное количество корней. В этом случае функция вернет **\`num_roots = 0\`** и ошибку или **\`num_roots = 3\`** и предупреждение. **Это можно настроить в разделе CONFIG заголовочного файла**, по умолчанию функция вернет 0 и ошибку.
* `solve_equation_return_status err`: код статуса выполнения. **0 означает успешное выполнение, отрицательные значения означают предупреждения, положительные значения означают ошибки.**
* `const char* status_message`: указатель на строковый литерал с сообщением о статусе выполнения.

#### Обратите внимание, что поведение этой функции может быть настроено в зависимости от параметров конфигурации в заголовочном файле.
В частности, можно настроить использование libquadmath (вычисления над float128) и поведение функции при нулевых значениях всех коэффициентов.

## Тесты и отчет о покрытии
### Тесты:
**Запустите** `make check`**, чтобы запустить тесты.** Эта команда скомпилирует модуль в статическую библиотеку, свяжет ее с файлом тестов и запустит тесты. Для ее выполнения в папке тестов должен лежать файл исходного кода тестов. По умолчанию это `tests/unittests.c`, а файл предоставляется в репозитории.

Альтернативно, файл исходного кода тестов может быть собран из модулей `*.check` в папке тестов (по умолчанию, `unit_tests/`).\
**Для этого запустите цель** `make unittests`. Сборка работает следующим образом:
1. Все модули `*.check` будут объединены в один файл `.check`. Модуль `include.check` всегда будет вверху, используйте этот файл для включения заголовков и объявления того, что необходимо для тестов.
2. Утилита `checkmk` преобразует объединенный файл `.check` в файл исходного кода тестов и помещает его в папку тестов.
### Отчет о покрытии:
**Запустите** `make gcov`, **чтобы создать отчет о покрытии в формате .html и открыть его в браузере по умолчанию**\
Файлы отчета о покрытии gcda/gcno автоматически генерируются тестами. Эта цель использует утилиту `gcovr` для создания из них .html отчёта.


## Логика функции solve_equation()
В целом, функция `solve_equation` работает следующим образом:
1. Принимает коэффициенты квадратного уравнения в качестве аргументов `double a, b, c`
2. Проверяет коэффициенты на валидность (отсутствие INF или NAN) и преобразует их в переменные типа float128 или long double.
3. Начинает проверять их на ноль в порядке `a` до `c`.
4. Если `a` **не равно** нулю, решает квадратное уравнение:
    * Вычисляет дискриминант. Если он выходит из диапазона (становится INF), нормализует коэффициенты и вычисляет его снова.
    * Если `дискриминант положительный`, находит два корня. Функция затем пересчитывает корень с меньшим абсолютным значением из большего по теореме Виета. Если хотя бы один из корней равен бесконечности, функция пытается пересчитать их заново по альтернативной формуле.
    * Если `дискриминант равен нулю`, находит один корень, но все равно копирует его в обе ячейки массива.
    * Если `дискриминант отрицательный`, корней нет, возвращает NaN и код состояния OK.
5. Если `a` равно нулю, но `b` **не равно** нулю, решает линейное уравнение.
6. Если `b` также равно нулю, но `c` **не равно** нулю, корней нет, возвращает NaN и код состояния OK.
7. Если все три коэффициента равны нулю, существует бесконечное количество корней. Эта ситуация обрабатывается в соответствии с конфигурацией в файле заголовка, возвращая либо предупреждение, либо ошибку.
